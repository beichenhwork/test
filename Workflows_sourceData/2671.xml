<?xml version="1.0" encoding="UTF-8" standalone="yes"?><ns2:tesla_experiment createTime="1319797859453" singleton="false" state="1" version="0" id="0" xmlns:ns2="http://spinfo.uni-koeln.de/tesla">    <documentCollections>        <entry>            <key>sig_1</key>            <value numberOfDocuments="1" width="370" posY="36" posX="276" type="text" localId="sig_1">                <description>A selection of 1 documents, created by jhermes</description>                <name>PIII Codebook</name>                <producesRoles>ri1109053198</producesRoles>                <producesRoles>ri-1715658718</producesRoles>                <producesRoles>ri-158299318</producesRoles>                <documentReferences reader="0f3eec28-04d1-4236-8db6-c61dd59beeb7" md5="f8801f56b7b453d14c7628e754eda4b0" dataSourceId="tesla"/>                <temporaryId>43c3fafe-0d8f-4249-9e1c-a41d5dbb45c8</temporaryId>                <xmlId>43c3fafe-0d8f-4249-9e1c-a41d5dbb45c8</xmlId>            </value>        </entry>    </documentCollections>    <reader_component readerLevel="80" localId="0f3eec28-04d1-4236-8db6-c61dd59beeb7" version="0.1" name="Tika Reader" width="0" posY="0" posX="0">        <className>de.uni_koeln.spinfo.tesla.component.reader.tika.DefaultTikaReader</className>        <produces_role localId="ri-1715658718" localName="URLs" roleDefinitionId="de.uni_koeln.spinfo.tesla.roles.tokenizer.UrlDetector">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.expressions.impl.hibernate.data.Url</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.expressions.impl.hibernate.access.UrlAccessAdapter</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.hibernate.DefaultHibernateOutputAdapter</outputAdapterImplementation>            <idInChain>-1715658718</idInChain>            <displayName>URL Detector</displayName>            <description>General information about this role: Detects URLs.</description>        </produces_role>        <produces_role localId="ri-158299318" localName="Paragraphs" roleDefinitionId="de.uni_koeln.spinfo.tesla.roles.tokenizer.ParagraphDetector">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.tokenizer.impl.hibernate.data.Paragraph</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.tokenizer.impl.tunguska.access.TParagraphAccessAdapter</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.tunguska.DefaultTunguskaOutputAdapter$ProtoStuff</outputAdapterImplementation>            <idInChain>-158299318</idInChain>            <displayName>Paragraph Detector</displayName>            <description>General information about this role: Detects paragraph boundaries.</description>        </produces_role>        <produces_role localId="ri1109053198" localName="DC Meta Data" roleDefinitionId="de.uni_koeln.spinfo.tesla.rolesystem.presets.roles.DublinCoreMetadataGenerator">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.dc.impl.hibernate.DublinCoreMetaDataImpl</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.dc.impl.hibernate.DublinCoreMetaDataAccessAdapterImpl</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.hibernate.DefaultHibernateOutputAdapter</outputAdapterImplementation>            <idInChain>1109053198</idInChain>            <displayName>Dublin Core Metadata Generator</displayName>            <description>General information about this role: Generates Dublin Core metadata annotations.</description>        </produces_role>        <consumes_role/>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Detect URLs">            <description>If enabled (default), the reader will detect URLs and generate corresponding annotations.</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Reuse Results">            <description>If false, this component will be executed whenever used in an experiment. If true, the annotations produced by this component earlier will be reused if the execution prerequesites did not change.</description>            <value>false</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <author login="anonymous">            <name>Stephan Schwiebert</name>            <email>sschwieb@spinfo.uni-koeln.de</email>            <organization>Department of Computational Linguistics, University of Cologne</organization>            <reference>http://www.spinfo.phil-fak.uni-koeln.de/sschwieb.html</reference>        </author>        <description>A general purpose reader which uses Apache Tika, such that it supports various formats, like RTF, PDF, ODF, HTML and MS Office. Note, however, that the structure of a document will not be extracted or annotated.</description>        <consumedSignals>            <item type="text" referencedObject="43c3fafe-0d8f-4249-9e1c-a41d5dbb45c8" name="fixme 789"/>        </consumedSignals>        <webReference>http://tika.apache.org/</webReference>        <type>java.lang.String</type>    </reader_component>    <component localId="f20f9ea3-dca6-452e-8a0e-40386264f43a" version="1.0" name="SPre" width="190" posY="174" posX="311">        <className>de.uni_koeln.spinfo.tesla.component.spre.SPre2Component</className>        <produces_role localId="ri-664934613" localName="Tokens" roleDefinitionId="de.uni_koeln.spinfo.tesla.roles.tokenizer.Tokenizer">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.core.impl.hibernate.data.Token</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.tokenizer.impl.tunguska.access.TTokenizerAccessAdapter</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.tunguska.DefaultTunguskaOutputAdapter$ProtoStuff</outputAdapterImplementation>            <idInChain>-664934613</idInChain>            <displayName>Tokenizer</displayName>            <description>General information about this role: Detects linguistic tokens.</description>        </produces_role>        <produces_role localId="ri-242024622" localName="Sentences" roleDefinitionId="de.uni_koeln.spinfo.tesla.roles.tokenizer.SentenceDetector">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.tokenizer.impl.hibernate.data.Sentence</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.tokenizer.impl.tunguska.access.TSentenceTokenAccessAdapter</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.tunguska.DefaultTunguskaOutputAdapter$ProtoStuff</outputAdapterImplementation>            <idInChain>-242024622</idInChain>            <displayName>Sentence Detector</displayName>            <description>General information about this role: Detects sentence boundaries.</description>        </produces_role>        <consumes_role/>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.FallbackConfigurationEditor" category="Parser 1 Config">            <description>Configurations for the SPre Character parser</description>            <value>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;spre:characterParser    xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"    xmlns:spre="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreCharacterParser"    xs:schemaLocation="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreCharacterParser SPreCharacterParser.xsd"&gt;    &lt;spre:layer&gt;CharacterLayer&lt;/spre:layer&gt;    &lt;spre:tokens&gt;        &lt;!-- ++++++++++++ --&gt;        &lt;!-- Letter &amp; digit items will be generated --&gt;        &lt;!-- ++++++++++++ --&gt;        &lt;spre:token name="generateUnicodeTokens"&gt;config&lt;/spre:token&gt;        &lt;!-- +++++++++++++++++ --&gt;        &lt;!-- Punctuation items --&gt;        &lt;!-- +++++++++++++++++ --&gt;        &lt;spre:token name="Dot"&gt;.&lt;/spre:token&gt;        &lt;spre:token name="QuestionMark"&gt;?&lt;/spre:token&gt;        &lt;spre:token name="ExclamationMark"&gt;!&lt;/spre:token&gt;        &lt;spre:token name="Comma"&gt;,&lt;/spre:token&gt;        &lt;spre:token name="Colon"&gt;:&lt;/spre:token&gt;        &lt;spre:token name="SemiColon"&gt;;&lt;/spre:token&gt;        &lt;spre:token name="Hyphen"&gt;-&lt;/spre:token&gt;        &lt;spre:token name="ParenthesisOpen"&gt;(&lt;/spre:token&gt;        &lt;spre:token name="ParenthesisClose"&gt;)&lt;/spre:token&gt;        &lt;spre:token name="BracketOpen"&gt;[&lt;/spre:token&gt;        &lt;spre:token name="BracketClose"&gt;]&lt;/spre:token&gt;        &lt;spre:token name="BraceOpen"&gt;{&lt;/spre:token&gt;        &lt;spre:token name="BraceClose"&gt;}&lt;/spre:token&gt;        &lt;spre:token name="LowerThan"&gt;&amp;lt;&lt;/spre:token&gt;        &lt;spre:token name="GreaterThan"&gt;&amp;gt;&lt;/spre:token&gt;        &lt;spre:token name="Apostroph"&gt;&amp;apos;&lt;/spre:token&gt;        &lt;spre:token name="Quotation"&gt;&amp;quot;&lt;/spre:token&gt;        &lt;spre:token name="Slash"&gt;/&lt;/spre:token&gt;        &lt;spre:token name="Backslash"&gt;\&lt;/spre:token&gt;        &lt;!-- +++++++++++++++ --&gt;        &lt;!-- Line feed items --&gt;        &lt;!-- +++++++++++++++ --&gt;        &lt;spre:token name="LineFeed"&gt;&amp;#x000a;&lt;/spre:token&gt;        &lt;spre:token name="CRLineFeed"&gt;&amp;#x000d;&amp;#x000a;&lt;/spre:token&gt;        &lt;!-- +++++++++++++++++ --&gt;        &lt;!-- White space items --&gt;        &lt;!-- +++++++++++++++++ --&gt;        &lt;!-- Character-Tab --&gt;        &lt;spre:token name="Tab"&gt;&amp;#x0009;&lt;/spre:token&gt;        &lt;!-- Blank --&gt;        &lt;spre:token name="Space"&gt;&amp;#x0020;&lt;/spre:token&gt;        &lt;!-- +++++++++++++ --&gt;        &lt;!-- Further items --&gt;        &lt;!-- +++++++++++++ --&gt;        &lt;spre:token name="Paragraph"&gt;§&lt;/spre:token&gt;        &lt;spre:token name="Percent"&gt;%&lt;/spre:token&gt;        &lt;spre:token name="Ampersand"&gt;&amp;#x0026;&lt;/spre:token&gt;        &lt;spre:token name="Equals"&gt;=&lt;/spre:token&gt;        &lt;spre:token name="Asterisk"&gt;*&lt;/spre:token&gt;        &lt;spre:token name="Plus"&gt;+&lt;/spre:token&gt;        &lt;spre:token name="Sharp"&gt;#&lt;/spre:token&gt;        &lt;spre:token name="Underscore"&gt;_&lt;/spre:token&gt;        &lt;spre:token name="ParagraphSeparator"&gt;&amp;#x2029;&lt;/spre:token&gt;    &lt;/spre:tokens&gt;    &lt;spre:tokenClasses&gt;        &lt;!-- Letter and Digit classes will be auto generated! --&gt;        &lt;spre:tokenClass name="Stop"&gt;            &lt;spre:item&gt;SemiStop&lt;/spre:item&gt;            &lt;spre:item&gt;FullStop&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="SemiStop"&gt;            &lt;spre:item&gt;Comma&lt;/spre:item&gt;            &lt;spre:item&gt;Colon&lt;/spre:item&gt;            &lt;spre:item&gt;SemiColon&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="FullStop"&gt;            &lt;spre:item&gt;Dot&lt;/spre:item&gt;            &lt;spre:item&gt;QuestionMark&lt;/spre:item&gt;            &lt;spre:item&gt;ExclamationMark&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="Punctuation"&gt;            &lt;spre:item&gt;Stop&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="Parenthetical"&gt;            &lt;spre:item&gt;ParentheticalOpen&lt;/spre:item&gt;            &lt;spre:item&gt;ParentheticalClose&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="ParentheticalOpen"&gt;            &lt;spre:item&gt;ParenthesisOpen&lt;/spre:item&gt;            &lt;spre:item&gt;BracketOpen&lt;/spre:item&gt;            &lt;spre:item&gt;BraceOpen&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="ParentheticalClose"&gt;            &lt;spre:item&gt;ParenthesisClose&lt;/spre:item&gt;            &lt;spre:item&gt;BracketClose&lt;/spre:item&gt;            &lt;spre:item&gt;BraceClose&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="WhiteSpace"&gt;            &lt;spre:item&gt;Tab&lt;/spre:item&gt;            &lt;spre:item&gt;Space&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;!-- This class comprises everything that clearly divides words above including WhiteSpace --&gt;        &lt;spre:tokenClass name="Divider"&gt;            &lt;spre:item&gt;NewLine&lt;/spre:item&gt;            &lt;spre:item&gt;WhiteSpace&lt;/spre:item&gt;            &lt;spre:item&gt;Plus&lt;/spre:item&gt;            &lt;spre:item&gt;Paragraph&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="NewLine"&gt;            &lt;spre:item&gt;LineFeed&lt;/spre:item&gt;            &lt;spre:item&gt;CRLineFeed&lt;/spre:item&gt;            &lt;spre:item&gt;ParagraphSeparator&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="Other"&gt;            &lt;spre:item&gt;Percent&lt;/spre:item&gt;            &lt;spre:item&gt;Ampersand&lt;/spre:item&gt;            &lt;spre:item&gt;Equals&lt;/spre:item&gt;            &lt;spre:item&gt;Asterisk&lt;/spre:item&gt;            &lt;spre:item&gt;Sharp&lt;/spre:item&gt;            &lt;spre:item&gt;Underscore&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;    &lt;/spre:tokenClasses&gt;&lt;/spre:characterParser&gt;</value>            <comment>Character parser for all unicoded texts</comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="0" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.FallbackConfigurationEditor" category="Parser 2 Config">            <description>Configurations for the SPre parser based on the character parser</description>            <value>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;spre:defaultParser    xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"    xmlns:spre="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreDefaultParser"    xs:schemaLocation="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreDefaultParser SPreDefaultParser.xsd"&gt;    &lt;!-- ************* --&gt;    &lt;!-- 1. The tokens --&gt;    &lt;!-- ************* --&gt;    &lt;spre:layer&gt;WordLayer&lt;/spre:layer&gt;    &lt;spre:tokens&gt;        &lt;!-- The tokenClass Unprocessable will always be generated by the        characterParser. It's a bit problematic that the name is only fixed        on the level of the source code. --&gt;        &lt;spre:token name="UnprocessableTokenSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Unprocessable&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;Unprocessable&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="UnprocessableToken"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Unprocessable&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;!-- ******************** --&gt;        &lt;!-- 1.1 The "Word" token --&gt;        &lt;!-- ******************** --&gt;            &lt;spre:token name="Word"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Letter&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;Alphanumeric&lt;/spre:contains&gt;                &lt;spre:contains&gt;Dot&lt;/spre:contains&gt;                &lt;spre:contains&gt;Hyphen&lt;/spre:contains&gt;                &lt;spre:contains&gt;Slash&lt;/spre:contains&gt;                &lt;spre:contains&gt;Backslash&lt;/spre:contains&gt;                &lt;spre:ambiguity&gt;                    &lt;spre:element&gt;Dot&lt;/spre:element&gt;                    &lt;!-- Merge the ambigue element with the previous element's belonging                    WordLevel-element if the condition isAbbreviation is met. --&gt;                    &lt;spre:merge type="left"&gt;                          &lt;spre:sequence&gt;                            &lt;spre:element&gt;Letter&lt;/spre:element&gt;                            &lt;spre:element&gt;Dot&lt;/spre:element&gt;                            &lt;spre:element&gt;Divider&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                       &lt;!--The idea is that conditions call methods, defined in &lt;spre:condition ...&gt;,                        to check for special properties of the item in question. The parameters                        of the respective method is String, in this case the Token "Word" that                        results by applying this Merge operation.--&gt;                      &lt;spre:conditions&gt;                            &lt;spre:condition&gt;Abbreviations&lt;/spre:condition&gt;                        &lt;/spre:conditions&gt;                     &lt;/spre:merge&gt;                  &lt;spre:merge type="left"&gt;                        &lt;spre:sequence&gt;                            &lt;spre:element&gt;Letter&lt;/spre:element&gt;                            &lt;spre:element&gt;Dot&lt;/spre:element&gt;                            &lt;spre:element&gt;Divider&lt;/spre:element&gt;                            &lt;spre:element&gt;LowerCaseLetter&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                    &lt;/spre:merge&gt;                    &lt;!-- Merge all three elements to one of the type of the first element's                    WordLevel-element type. --&gt;                    &lt;spre:merge type="leftright"&gt;                        &lt;spre:sequence&gt;                            &lt;spre:element&gt;Alphanumeric&lt;/spre:element&gt;                            &lt;spre:element&gt;Dot&lt;/spre:element&gt;                            &lt;spre:element&gt;Alphanumeric&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                    &lt;/spre:merge&gt;                &lt;/spre:ambiguity&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;!-- ************************* --&gt;        &lt;!-- 1.2 The "Numerical" token --&gt;        &lt;!-- ************************* --&gt;        &lt;spre:token name="Numerical"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Digit&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;Digit&lt;/spre:contains&gt;                &lt;spre:contains&gt;Digit&lt;/spre:contains&gt;                &lt;spre:contains&gt;Dot&lt;/spre:contains&gt;                &lt;spre:contains&gt;Comma&lt;/spre:contains&gt;                &lt;spre:contains&gt;Slash&lt;/spre:contains&gt;                &lt;!-- First amgigue Element: "Dot" --&gt;                &lt;spre:ambiguity&gt;                    &lt;spre:element&gt;Dot&lt;/spre:element&gt;                    &lt;!--                    E.g. &lt;spre:merge Type="leftright"&gt;                    ... i n  4 3 . 5 %  a l l e r F ä l l e ...                    Here, "43.5" will be recognized as one token                    and merging "leftright" means that both parts                    left and right of the ambigue element "." will                    be joined.                    --&gt;                    &lt;spre:merge type="leftright"&gt;                        &lt;spre:sequence&gt;                            &lt;spre:element&gt;Digit&lt;/spre:element&gt;                            &lt;spre:element&gt;Dot&lt;/spre:element&gt;                            &lt;spre:element&gt;Digit&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                    &lt;/spre:merge&gt;                    &lt;!--                    E.g. &lt;spre:merge Type="left"&gt;                    ... b e i  d e r  2 0 .  ö f f e n t l i c h  a u s g e t r a g e n e n ...                    Here, "20." will be recognized as one token and merging                    'left' means that the dot will be interpreted as part of the                    numerical expression.                    --&gt;                    &lt;spre:merge type="left"&gt;                        &lt;spre:sequence&gt;                            &lt;spre:element&gt;Digit&lt;/spre:element&gt;                            &lt;spre:element&gt;Dot&lt;/spre:element&gt;                            &lt;spre:element&gt;WhiteSpace&lt;/spre:element&gt;                            &lt;spre:element&gt;LowerCaseLetter&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                    &lt;/spre:merge&gt;                &lt;/spre:ambiguity&gt;                &lt;!-- Second ambigue element: "Comma" --&gt;                &lt;spre:ambiguity&gt;                    &lt;!--                    E.g. &lt;spre:merge Type="leftright"&gt;                    ... i n  4 3 , 5 %  a l l e r F ä l l e ...                    Here, "43,5" will be recognized as one token                    and merging "leftright" means that both parts                    left and right of the ambigue element "." will                    be joined.                    --&gt;                    &lt;spre:element&gt;Comma&lt;/spre:element&gt;                    &lt;spre:merge type="leftright"&gt;                        &lt;spre:sequence&gt;                            &lt;spre:element&gt;Digit&lt;/spre:element&gt;                            &lt;spre:element&gt;Comma&lt;/spre:element&gt;                            &lt;spre:element&gt;Digit&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                    &lt;/spre:merge&gt;                &lt;/spre:ambiguity&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;!-- **************** --&gt;        &lt;!-- 1.3 Other tokens --&gt;        &lt;!-- **************** --&gt;        &lt;spre:token name="FullStopSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Dot&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;Dot&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="ExclamationMarkSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;ExclamationMark&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;ExclamationMark&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="QuestionMarkSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;QuestionMark&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;QuestionMark&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="MixedSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;ExclamationMark&lt;/spre:startsWith&gt;                &lt;spre:startsWith&gt;QuestionMark&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;ExclamationMark&lt;/spre:contains&gt;                &lt;spre:contains&gt;QuestionMark&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;         &lt;spre:token name="Apostroph"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Apostroph&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="Slash"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Slash&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="FullStop"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Dot&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="ExclamationMark"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;ExclamationMark&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="QuestionMark"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;QuestionMark&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="Comma"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Comma&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="Colon"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Colon&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="SemiColon"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;SemiColon&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="SingleQuote"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Apostroph&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="DoubleQuote"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Quotation&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="ParentheticalOpen"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;ParentheticalOpen&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="ParentheticalClosed"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;ParentheticalClose&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="NewLine"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;NewLine&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="ParagraphSeparator"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;ParagraphSeparator&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;    &lt;/spre:tokens&gt;    &lt;!-- ******************* --&gt;    &lt;!-- 2. The tokenClasses --&gt;    &lt;!-- ******************* --&gt;    &lt;spre:tokenClasses&gt;        &lt;spre:tokenClass name="Unprocessable"&gt;            &lt;spre:item&gt;UnprocessableToken&lt;/spre:item&gt;            &lt;spre:item&gt;UnprocessableTokenSequence&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="FullStops"&gt;            &lt;spre:item&gt;FullStop&lt;/spre:item&gt;            &lt;spre:item&gt;ExclamationMark&lt;/spre:item&gt;            &lt;spre:item&gt;QuestionMark&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;    &lt;/spre:tokenClasses&gt;&lt;/spre:defaultParser&gt;</value>            <comment>Word parser for german texts</comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="0" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.FallbackConfigurationEditor" category="Parser 3 Config">            <description>Configurations for the SPre parser based on the secondary parser</description>            <value>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;spre:defaultParser    xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"    xmlns:spre="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreDefaultParser"    xs:schemaLocation="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreDefaultParser SPreDefaultParser.xsd"&gt;    &lt;spre:layer&gt;SentenceLayer&lt;/spre:layer&gt;    &lt;!-- ************* --&gt;    &lt;!-- 1. The tokens --&gt;    &lt;!-- ************* --&gt;    &lt;spre:tokens&gt;        &lt;!-- The tokenClass Unprocessable will always be generated by the        characterParser. It's a bit problematic that the name is only fixed        on the level of the source code. --&gt;        &lt;spre:token name="UnprocessableTokenSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Unprocessable&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;Unprocessable&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="UnprocessableToken"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Unprocessable&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;!-- ******************** --&gt;        &lt;!-- 1.1 The "Sentence" token --&gt;        &lt;!-- ******************** --&gt;        &lt;spre:token name="Sentence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Word&lt;/spre:startsWith&gt;                &lt;spre:endsWith&gt;FullStops&lt;/spre:endsWith&gt;            &lt;/spre:pattern&gt;                   &lt;/spre:token&gt;&lt;!-- 	&lt;spre:token name="NoSentence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Word&lt;/spre:startsWith&gt;                &lt;spre:endsWith&gt;NewLine&lt;/spre:endsWith&gt;            &lt;/spre:pattern&gt;                   &lt;/spre:token&gt; --&gt;            &lt;/spre:tokens&gt;     &lt;spre:tokenClasses&gt;        &lt;spre:tokenClass name="Sentence"&gt;            &lt;spre:item&gt;Sentence&lt;/spre:item&gt;                    &lt;/spre:tokenClass&gt;  &lt;!--		&lt;spre:tokenClass name="NoSentence"&gt;            &lt;spre:item&gt;NoSentence&lt;/spre:item&gt;                    &lt;/spre:tokenClass&gt;        --&gt;       &lt;/spre:tokenClasses&gt;  &lt;/spre:defaultParser&gt;</value>            <comment>Sentence parser for german texts</comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.NamedListEditor" category="Abbreviations">            <description>List of abbreviations</description>            <value>AbbreviationsA.A.A.a.a.a.a.O.Abb.Abbr.Abg.Abk.Abs.Abt.A.C.A.D.a.d.a.D.agr.allg.Alt.a.m.amerik.Anm.a.o.A.T.B.B.c.B.C.Bd.Bev.Bj.Bsp.Btl.bzw.C.ca.chin.Co.Ct.D.D.C.Dez.d.h.Di.Dipl.Do.Dr.dt.E.e.e.G.engl.etc.e.V.ev.F.f.Fr.franz.G.Gef.gegr.gem.ggf.GMBl.Grp.H.habil.Hbf.hist.höchst.Hptm.I.i.A.id.i.d.F.I.K.I.L.Inc.incl.inkl.i.S.v.ital.i.V.i.V.m.J.jap.Jh.jmd.Jt.K.kath.K.O.Kp.L.lat.Ld.Lj.M.m.m.b.L.med.Mi.Mill.Min.mind.Mio.Mo.Mr.Mrd.Mrs.Msp.m.W.v.N.Nr.N.T.N.Y.o.g.O.o.O.P.p.a.Pfd.pl.p.m.P.M.Prof.prot.Q.Q.b.A.q.e.d.Qual.Quant.R.reg.rer.S.Sa.san.sgl.So.sog.span.Std.Str.-str.svw.T.Tel.U.u.a.ugs.urspr.usw.u.ä.u.U.V.v.Chr.Vfg.Vgl.v.H.vs.W.Wdh.Wv.X.Y.Z.z.A.z.B.Zbl.z.d.A.z.Hd.Zi.z.T.Ztr.z.V.zw.z.Z.z.Zt.zzgl.ä.Ä.ö.Ö.ü.Ü.</value>            <comment>List of german abbreviations</comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Reuse Results">            <description>If false, this component will be executed whenever used in an experiment. If true, the annotations produced by this component earlier will be reused if the execution prerequesites did not change.</description>            <value>false</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <author login="anonymous">            <name>Jürgen Hermes</name>            <email>jhermes@spinfo.uni-koeln.de</email>            <organization>Sprachliche Informationsverarbeitung</organization>            <reference>http://www.phil-fak.uni-koeln.de/spinfo-juergenhermes.html</reference>        </author>        <author login="anonymous">            <name>Christoph Benden</name>            <email>cbenden@spinfo.uni-koeln.de</email>            <organization>Sprachliche Informationsverarbeitung</organization>            <reference>No external URL defined</reference>        </author>        <description>A configurable layered tokenizer.</description>        <consumedSignals>            <item type="text" referencedObject="43c3fafe-0d8f-4249-9e1c-a41d5dbb45c8" name="texts"/>        </consumedSignals>        <webReference>No external URL defined</webReference>    </component>    <component localId="c4f4452f-2726-4afa-9a95-98f33002daec" version="1.0" name="Morphemizer" width="150" posY="300" posX="588">        <className>de.uni_koeln.spinfo.formanalysis.teslacomponents.SimpleMorphemizerComponent</className>        <produces_role localId="ri1622039516" localName="Morphemes" roleDefinitionId="de.uni_koeln.spinfo.tesla.roles.tokenizer.MorphemeAnalyzer">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.core.impl.hibernate.data.Token</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.tokenizer.impl.tunguska.access.TTokenizerAccessAdapter</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.tunguska.DefaultTunguskaOutputAdapter</outputAdapterImplementation>            <idInChain>1622039516</idInChain>            <displayName>Morphemizer</displayName>            <description>General information about this role: Detects graphems using sucessor/predecessor counts. Provides access on words morphemes.</description>        </produces_role>        <consumes_role>            <item name="Words">                <includedObject xsi:type="roleDefinition" localId="-664934613" local_id="ri-664934613" maxOccurrences="1" minOccurrences="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">                    <displayName>Tokenizer</displayName>                    <description>Detects linguistic tokens.</description>                    <roleDefinitionId>de.uni_koeln.spinfo.tesla.roles.tokenizer.Tokenizer</roleDefinitionId>                    <implementingComponent>f20f9ea3-dca6-452e-8a0e-40386264f43a</implementingComponent>                    <idInChain>-664934613</idInChain>                    <accessAdapterInterface>de.uni_koeln.spinfo.tesla.roles.tokenizer.access.ITokenAccessAdapter</accessAdapterInterface>                    <dataObjectInterface>de.uni_koeln.spinfo.tesla.roles.tokenizer.data.IToken</dataObjectInterface>                </includedObject>            </item>        </consumes_role>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.IntegerEditor" category="Min word length">            <description>Determines the minimal length of words that should be analysed</description>            <value>3</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.IntegerEditor" category="Evidence Level">            <description>Determines the minimal score for morpheme boundaries</description>            <value>3</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Solely maximum splitter">            <description>If true, words will be splittet to morphemes solely at the maximum evidence value</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.IntegerEditor" category="Iterations">            <description>Count of re-analyses with detected morphemes treated as words</description>            <value>1</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Include affix position">            <description>If true, accepted morpheme partitions must have a prefix in first, infix in mid and suffix in last position.</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Include increasing predecessor counts">            <description>If true, increasing predecessor counts score</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Include increasing successor counts">            <description>If true, increasing successor counts score</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Include lokal max predecessor counts">            <description>If true, lokal maximum predecessor counts score</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Include max predecessor counts">            <description>If true, maximum predecessor counts score</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Include lokal max successor counts">            <description>If true, lokal maximum successor counts score</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Include max predecessor counts">            <description>If true, maximum succecessor counts score</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Include lokal max combined counts">            <description>If true, lokal maximum combined (successor + predecessor) counts score</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Include max combined counts">            <description>If true, maximum combined (successor + predecessor) counts score</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Label based statistics">            <description>if true, the word labels will be analysed instead of the signal content.</description>            <value>false</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.IntegerEditor" category="Min Tokens per Type">            <description>Determines how many occurences a type should have at least to be analyzed</description>            <value>1</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Reuse Results">            <description>If false, this component will be executed whenever used in an experiment. If true, the annotations produced by this component earlier will be reused if the execution prerequesites did not change.</description>            <value>false</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <author login="anonymous">            <name>Jürgen Hermes</name>            <email>jhermes@spinfo.uni-koeln.de</email>            <organization>Sprachliche Informationsverarbeitung</organization>            <reference>none</reference>        </author>        <description>Detects Morphemes using sucessor and predecessor counts.</description>        <consumedSignals/>        <webReference>none</webReference>    </component>    <displayName>Morpheme Analysis PIII</displayName>    <description>Experiment Description</description>    <creator login="jhermes">        <name>jhermes</name>        <email>hermesj@uni-koeln.de</email>        <organization>none</organization>        <reference></reference>    </creator></ns2:tesla_experiment>