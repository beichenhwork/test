<?xml version="1.0" encoding="UTF-8"?><workflow name="Sindbad_Parallel">  <interface>    <source name="scan_file" type="string" />    <source name="chain" type="string" />    <source name="phantom" type="string" />    <source name="geo" type="string" />    <source name="simulation_name" type="string" />    <source name="pegs4dat" type="string" />    <constant name="nb_jobs_max" type="string" value="360" cardinality="scalar" />    <constant name="nb_particules_par_job_max" type="string" value="1e+8" cardinality="scalar" />    <constant name="default_split" type="string" value="0" cardinality="scalar" />    <constant name="dataDir" type="string" value="data" cardinality="scalar" />    <constant name="pendingFile" type="string" value="/var/www/pending" cardinality="scalar" />    <constant name="sindbad_release" type="string" value="lfn://lfc-biomed.in2p3.fr:5010/grid/biomed/creatis/vip/tools/activitites/simulator_components/sindbad/sindbad-EGG/sindbad_parallel.tgz" cardinality="scalar" />    <sink name="TempFiles" type="string" />    <sink name="wait" type="string" />    <sink name="MC_merges" type="string" />    <sink name="ResultFile_2" type="string" />    <sink name="ResultFile" type="string" />    <sink name="LocalFile_2" type="string" />    <sink name="new output" type="string" />  </interface>  <processors>    <processor name="count_in_dir" >      <in name="nb_ana" type="string" depth="0" />      <in name="directory" type="string" depth="0" />      <in name="nb_mc" type="string" depth="0" />      <out name="elsebranch" type="string" depth="0" />      <out name="thenbranch" type="string" depth="0" />      <iterationstrategy>        <cross>          <port name="directory" />          <port name="nb_ana" />          <port name="nb_mc" />        </cross>      </iterationstrategy>      <beanshell>//------------Beginning of Beanshell--------------////Method execute//Launch a bash processus on the server.//Return exit code//copy it to use in your beanshell.public int execute (Process p, String[] cmd){try{        Runtime rt = Runtime.getRuntime();	p = rt.exec(cmd);	p.waitFor();	BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()));	String line ="";	while((line=in.readLine())!=null){            System.out.println(line);	}        BufferedReader err = new BufferedReader(new InputStreamReader(p.getErrorStream()));	String lineerr ="";	while((lineerr = err.readLine())!=null){            System.out.println(lineerr);	}        p.getErrorStream().close();	p.getInputStream().close();	p.getOutputStream().close();}  catch(Exception e){            e.printStackTrace();}return p.exitValue();}//End of method execute//code for counting number of files in a directory starts here.//copy it for use in your beanshell    if  ( ! directory.contains("/grid") ){    throw new Exception("file not stored on lfn:/grid/");}String lfn = directory.substring( directory.indexOf ("/grid") );while (lfn.endsWith("/"))     {lfn = lfn.substring(0, lfn.lastIndexOf("/") );}String lfn_merge=lfn+"_merging";int count=0;int trycount=0;boolean merging=false;boolean success=false;int sleep_time=10;int sleep_increment=30;while ( success!=true &amp;&amp; trycount &lt; 5) {    if (trycount&gt;0){       System.out.println("Sleeping "+sleep_time+" seconds before next try");         Thread.currentThread().sleep(sleep_time*1000);         sleep_time+=sleep_increment;    }    count=0;    Process p1 = null;    String[] cmd1= new String[3];    cmd1[0]="lfc-ls";    cmd1[1]="-l";    cmd1[2]=lfn;        try{        Runtime rt = Runtime.getRuntime();	p1 = rt.exec(cmd1);	p1.waitFor();	BufferedReader in = new BufferedReader(new InputStreamReader(p1.getInputStream()));	String line ="";	while((line=in.readLine())!=null){            if ( line.startsWith("-r") )	{count++;}	}        BufferedReader err = new BufferedReader(new InputStreamReader(p1.getErrorStream()));	String lineerr ="";	while((lineerr = err.readLine())!=null){            System.out.println(lineerr);	}        p1.getErrorStream().close();	p1.getInputStream().close();	p1.getOutputStream().close();	}        catch(Exception e){            e.printStackTrace();	}   if(p1.exitValue() == 0){         merging=false;         success=true;         break;    }    Process p2 = null;    String[] cmd2= new String[3];    cmd2[0]="lfc-ls";    cmd2[1]="-d";    cmd2[2]=lfn_merge; if(execute(p2,cmd2) == 0){         merging=true;         success=true;         break;    } trycount++; System.out.println("lfc-ls did not work, or directory"+lfn+"is incorrect");    }if (success!=true){    throw new Exception("unable to find "+lfn+" or "+lfn_merge);    } else{if (merging == true){thenbranch="null";elsebranch=lfn_merge+" is already processing";} else {      if ( count == Integer.parseInt(nb_mc)+Integer.parseInt(nb_ana)) {           trycount=0;           success=false;           sleep_time=10;           while ( success!=true &amp;&amp; trycount &lt; 5) {               if (trycount&gt;0){                    System.out.println("Sleeping "+sleep_time+" seconds before next try");                    Thread.currentThread().sleep(sleep_time*1000);                    sleep_time+=sleep_increment;               }               Process p3 = null;               String[] cmd3= new String[3];               cmd3[0]="lfc-rename";               cmd3[1]=lfn;               cmd3[2]=lfn_merge;               if (execute(p3,cmd3) == 0){                   success=true;                   break;               }               trycount++;               System.out.println("lfc-rename did not work");          }         if (success != true) {           System.out.println("unable to rename "+lfn+". Still going.");           thenbranch=lfn;           elsebranch="null";         } else {           thenbranch=lfn_merge;           elsebranch="null";         }      } else {        thenbranch="null";        elsebranch=lfn+" only have "+count+" images ready. Waiting";           } } }      </beanshell>    </processor>    <if name="test_start_merge" >      <in name="else_in" type="string" depth="0" />      <in name="then_in" type="string" depth="0" />      <out name="out_else" type="string" depth="0" />      <out name="out_then" type="string" depth="0" />      <iterationstrategy>        <dot>          <port name="then_in" />          <port name="else_in" />        </dot>      </iterationstrategy>      <condition>( ! then_in.equals("null") )</condition>      <then>out=then_in</then>      <else>out = else_in</else>    </if>    <if name="test_use_split" >      <in name="nb_split" type="string" depth="0" />      <in name="sindbad_result" type="string" depth="0" />      <out name="lfn_output_then" type="string" depth="0" />      <out name="lfn_output_else" type="string" depth="0" />      <iterationstrategy>        <cross>          <port name="nb_split" />          <port name="sindbad_result" />        </cross>      </iterationstrategy>      <condition>Integer.parseInt(nb_split) != 0</condition>      <then>lfn_output= sindbad_result.substring(0,sindbad_result.lastIndexOf("/") )</then>      <else>lfn_output= sindbad_result</else>    </if>    <processor name="merge" >      <in name="input3" type="string" depth="0" />      <in name="input2" type="string" depth="0" />      <in name="input5" type="string" depth="0" />      <in name="input4" type="string" depth="0" />      <in name="input7" type="string" depth="0" />      <in name="input6" type="string" depth="0" />      <in name="input1" type="string" depth="0" />      <in name="input0" type="string" depth="0" />      <out name="result1" type="string" depth="0" />      <out name="result0" type="string" depth="0" />      <iterationstrategy>        <cross>          <port name="input0" />          <port name="input1" />          <port name="input2" />          <port name="input3" />          <port name="input4" />          <port name="input5" />          <port name="input6" />          <port name="input7" />        </cross>      </iterationstrategy>      <gasw descriptor="lfn://lfc-biomed.in2p3.fr:5010/grid/biomed/creatis/vip/tools/activitites/simulator_components/sindbad/sindbad_merge/Sindbad_merge.xml" />    </processor>    <processor name="appendDate" >      <in name="dir" type="string" depth="0" />      <out name="result" type="string" depth="0" />      <beanshell>/*----------Beginning of Beanshell------------*/import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;DateFormat dateFormat = new SimpleDateFormat("dd-MM-yyyy_HH:mm:ss");String result = dir+"/"+(dateFormat.format(System.currentTimeMillis()));/*------------End of Beanshell------------*/      </beanshell>    </processor>    <processor name="sindbad" >      <in name="input3" type="string" depth="0" />      <in name="input2" type="string" depth="0" />      <in name="input5" type="string" depth="0" />      <in name="input4" type="string" depth="0" />      <in name="input7" type="string" depth="0" />      <in name="input6" type="string" depth="0" />      <in name="input9" type="string" depth="0" />      <in name="input10" type="string" depth="0" />      <in name="input8" type="string" depth="0" />      <in name="input1" type="string" depth="0" />      <in name="input0" type="string" depth="0" />      <out name="result0" type="string" depth="0" />      <iterationstrategy>        <cross>          <dot>            <port name="input7" />            <port name="input8" />            <port name="input1" />          </dot>          <cross>            <dot>              <port name="input2" />              <port name="input9" />              <port name="input10" />            </dot>            <cross>              <port name="input6" />              <port name="input4" />              <port name="input5" />              <port name="input0" />              <port name="input3" />            </cross>          </cross>        </cross>      </iterationstrategy>      <gasw descriptor="lfn://lfc-biomed.in2p3.fr:5010/grid/biomed/creatis/vip/tools/activitites/simulator_components/sindbad/sindbad-EGG/Sindbad_EGG-p.xml" />    </processor>    <processor name="projection_count" >      <in name="scanfile" type="string" depth="0" />      <in name="nb_jobs_max" type="string" depth="0" />      <out name="nbproj_vector" type="string" depth="1" />      <out name="projection_id" type="string" depth="1" />      <out name="scan_vector" type="string" depth="1" />      <out name="nb_projection" type="string" depth="0" />      <out name="nb_split_max" type="string" depth="0" />      <iterationstrategy>        <cross>          <port name="scanfile" />          <port name="nb_jobs_max" />        </cross>      </iterationstrategy>      <beanshell>/*----------Beginning of Beanshell------------*/if  ( ! scanfile.contains("/grid") ){    throw new Exception("file not stored on lfn:/grid/");}String lfn = scanfile.substring( scanfile.indexOf ("/grid") );Process p1 = null;try{Runtime rt = Runtime.getRuntime();        String[] cmd1 = new String[3];        cmd1[0] = "lcg-cp";        cmd1[1] = "lfn:" + lfn;        cmd1[2] = "file:"+ lfn.substring(lfn.lastIndexOf('/') + 1);        p1 = rt.exec(cmd1);        p1.waitFor();        BufferedReader in = new BufferedReader(new InputStreamReader(p1.getInputStream()));        String line = "";        while ((line = in.readLine()) != null) {            System.out.println(line);        }        BufferedReader err = new BufferedReader(new InputStreamReader(p1.getErrorStream()));        String lineerr = "";        while ((lineerr = err.readLine()) != null) {            System.out.println(lineerr);        }        p1.getErrorStream().close();        p1.getInputStream().close();        p1.getOutputStream().close();        if (p1.exitValue() != 0)           {throw new Exception("Lcg-cp returned error code " + p1.exitValue());}} catch (Exception e){System.out.println("Problem downloading file " + lfn+" from LFN"); e.printStackTrace();}String projection = "" ;try {     BufferedReader awk = new BufferedReader(new FileReader(new File(lfn.substring(lfn.lastIndexOf('/') + 1))));     boolean broke =false;     while (  awk.ready() ) {          projection = awk.readLine();          if ( projection.contains("Nombre total de projections") ) {               projection = projection.split("[ \t]",2)[0];               broke =true;               break;    }     }     awk.close();   if ( broke == false)      {throw new Exception("Data not found in "+lfn.substring(lfn.lastIndexOf('/') + 1)+": Nombre total de projections");}} catch (Exception e){e.printStackTrace();}  int n1 = Integer.parseInt(projection);  int n2 = Integer.parseInt(nb_jobs_max);  int n = Math.min( n1, n2);  nb_split_max = String.valueOf( n2/n ) ;  nb_projection = String.valueOf( n );  projection_id = new ArrayList();  scan_vector = new ArrayList();  nbproj_vector = new ArrayList();  for (int i = 0; i&lt;n;i++) {    projection_id.add(""+i);    scan_vector.add(scanfile);    nbproj_vector.add(nb_projection);  }/*------------End of Beanshell------------*/      </beanshell>    </processor>    <processor name="split_count" >      <in name="nbsplit_default_value" type="string" depth="0" />      <in name="simufile" type="string" depth="0" />      <in name="nb_jobs_max" type="string" depth="0" />      <in name="nb_particule_max" type="string" depth="0" />      <out name="analytic" type="string" depth="0" />      <out name="split_id" type="string" depth="1" />      <out name="nb_split" type="string" depth="0" />      <out name="chaine_vector" type="string" depth="1" />      <out name="nbsplit_vector" type="string" depth="1" />      <iterationstrategy>        <cross>          <port name="nb_particule_max" />          <port name="nbsplit_default_value" />          <port name="simufile" />          <port name="nb_jobs_max" />        </cross>      </iterationstrategy>      <beanshell>/*------------Beginning of Beanshell-------------*//* Unknown_archive scope: class for extracting a tar or a zip archive.copy it to use it in your own beanshell */public class Unknown_archive {        import java.util.zip.*;    private String archive_name;    private String archive_type;public Unknown_archive (String name) throws Exception{        archive_name = name;        archive_type= "unknown";        if  (name.endsWith("zip"))            {archive_type= "zip";}        if (name.endsWith("gz") )            {archive_type= "tgz";}        if (name.endsWith("bz2") )            {archive_type="tbz2";}        if  (name.endsWith("tar"))            {archive_type="tar";}        if  (archive_type.equals("unknown"))            {throw new Exception("Unknown archive type");}}public ArrayList listEntries() throws Exception {   List entries = new ArrayList() ;   if (archive_type.equals("zip")) {        ZipInputStream extract = new ZipInputStream(new FileInputStream(archive_name));        ZipEntry file;        while ((file = extract.getNextEntry()) != null)            {entries.add(file.getName());}        extract.close();   } else {        Process p1 = null;        String opt = "";        if (archive_type.equals("tgz"))           {opt="z";}        if (archive_type.equals("tbz2"))            {opt="j";}        Runtime rt = Runtime.getRuntime();        String [] cmd1 = new String [3];        cmd1[0] = "tar";        cmd1[1] = "t"+opt+"f";        cmd1[2]=archive_name;	p1 = rt.exec(cmd1);	p1.waitFor();        BufferedReader in = new BufferedReader(new InputStreamReader(p1.getInputStream()));	String line ="";	while((line=in.readLine())!=null)             {entries.add(line);}        BufferedReader err = new BufferedReader(new InputStreamReader(p1.getErrorStream()));	String lineerr ="";	while((lineerr = err.readLine())!=null)             {System.out.println(lineerr);}        p1.getErrorStream().close();	p1.getInputStream().close();	p1.getOutputStream().close();   if (p1.exitValue()!=0)          {throw new Exception("Process "+cmd1[0]+" "+cmd1[1]+" "+cmd1[2]+" returned exit code "+p1.exitValue());}   }   return entries;}public void extract() throws Exception {    System.out.println("extracting "+archive_name);    if (archive_type.equals("zip")) {         ZipInputStream extract = new ZipInputStream(new FileInputStream(archive_name));         FileOutputStream written;         ZipEntry entry ;         int temp;         while ((entry = extract.getNextEntry()) != null) {           System.out.println("Extracting: " + entry.getName());           written = new FileOutputStream(entry.getName());           while ((temp = extract.read()) != -1)                {written.write(temp);}           written.close();         }    extract.close();        } else {        Process p1 = null;        String opt = "";        if (archive_type.equals("tgz"))           {opt="z";}        if (archive_type.equals("tbz2"))            {opt="j";}        Runtime rt = Runtime.getRuntime();        String [] cmd1 = new String [3];        cmd1[0] = "tar";        cmd1[1] = "xv"+opt+"f";        cmd1[2]=archive_name;                p1 = rt.exec(cmd1);	p1.waitFor();        BufferedReader in = new BufferedReader(new InputStreamReader(p1.getInputStream()));	String line ="";	while((line=in.readLine())!=null)            {System.out.println(line);}        BufferedReader err = new BufferedReader(new InputStreamReader(p1.getErrorStream()));	String lineerr ="";	while((lineerr = err.readLine())!=null)            {System.out.println(lineerr);}        p1.getErrorStream().close();	p1.getInputStream().close();	p1.getOutputStream().close();   if(p1.exitValue()!=0)      {throw new Exception("Process "+cmd1[0]+" "+cmd1[1]+" "+cmd1[2]+" returned exit code "+p1.exitValue());}   }    System.out.println(archive_name+" was successfully extracted");   return;}}/* End of Unknown_archve class */ /*Simu_file class: describe a sindbad parameter file in the mdf or archived formatcopy  and modify it for your own purposes*/ class Simu_file {      private String chaine;  private File MC_part;  private File conf_part;  private String calcul_mode;  private String particules;   Simu_file(String name) throws Exception{    calcul_mode = null;    particules = null;    chaine=name;  if ( chaine.endsWith(".mdf") ) {        this.MC_part=new File(name);        this.conf_part=new File(name);  } else {        Unknown_archive arch;        arch= new Unknown_archive(name);        arch.extract();        List files = arch.listEntries();        boolean broke=false;        for (int i=0;i&lt;files.size();i++) {            if ( files.get(i).endsWith(".conf") ) {                System.out.print("conf_file is "+files.get(i)+"\n");                conf_part=new File(files.get(i));                broke =true;                break;  }        }      if ( broke == false)         {throw new Exception("Data not found in "+chaine+": file .conf");}        MC_part = null;        BufferedReader awk = new BufferedReader(new FileReader(conf_part));        String MC = "";        broke= false;        while (awk.ready()) {            MC = awk.readLine();            if (MC.contains("CHAINE_MC=")) {                String[] split_MC = MC.split("[= \t]");                 for (int i = 0; i &lt; split_MC.length; i++) {                    if (split_MC[i].equals("CHAINE_MC")) {                        System.out.println("CHAINE_MC is "+split_MC[i + 1]);                        MC_part = new File(split_MC[i + 1]);                        broke = true;                        break;}                                    }                break; }            }       awk.close();     if ( broke == false)        {throw new Exception("Data not found in "+conf_part.getName()+": CHAINE_MC");}  }}public int getCalculMode() throws Exception {   if (calcul_mode == null ) {      String search;      BufferedReader awk = new BufferedReader(new FileReader(conf_part));      boolean broke= false;      while (awk.ready()) {          search = awk.readLine();          if (search.contains("CALCUL_MODE=")) {                String[] parse= search.split("[= \t]");                for (int i = 0; i &lt; parse.length; i++) {                    if (parse[i].equals("CALCUL_MODE")) {                        System.out.println("CALCUL_MODE is "+parse[i + 1]);                        calcul_mode =parse[i + 1];                        break;}                }                broke =true;                break; }          if ( search.contains("Modele de calcul") ) {               System.out.println("CALCUL_MODE is "+search.trim().substring(0,1));              calcul_mode= search.trim().substring(0,1);              broke= true;               break;}              }        awk.close();      if ( broke == false)         {throw new Exception("Data not found in "+conf_part.getName()+": CALCUL_MODE");}   }   return Integer.parseInt(calcul_mode);}public int getParticules() throws Exception {   if ( MC_part == null || this.getCalculMode() == 0 )        {return 0;}   else {        if (particules == null){            String search ;            BufferedReader awk = new BufferedReader(new FileReader(MC_part));            boolean broke =false;            while (awk.ready()) {                search = awk.readLine();                if ( search.contains("Nombre de particules envoyees")) {                      String[] parse=search.split("[Ee \t]",3);                      float max = Float.parseFloat(parse[0]);                      parse[1] = parse[1].replace('+','0');                      if ( parse[1].matches("^[0-9]+") ) {                             int exp = Integer.parseInt(parse[1]);                             for (int i = 0; i&lt;exp; i++)                                 {max = max*10; }                       }                      particules = String.valueOf((int) max);		      System.out.println("Number of simulated particles is "+particules);                      broke= true;                      break;}             }             awk.close();           if ( broke == false)              {throw new Exception("Data not found in "+MC_part.getName()+": Nombre de particules");}       }        return Integer.parseInt (particules) ;   }}}/*End of Simu_File Class *//*Main code: gets the number of particulecopy it to use it in your own beanshell (if you have any use for this)*/if  ( ! simufile.contains("/grid") ){    throw new Exception("file not stored on lfn:/grid/");}String lfn = simufile.substring( simufile.indexOf ("/grid") );Process p1 = null;try{Runtime rt = Runtime.getRuntime();        String[] cmd1 = new String[3];        cmd1[0] = "lcg-cp";        cmd1[1] = "lfn:" + lfn;        cmd1[2] = "file:"+ lfn.substring(lfn.lastIndexOf('/') + 1);        p1 = rt.exec(cmd1);        p1.waitFor();        BufferedReader in = new BufferedReader(new InputStreamReader(p1.getInputStream()));        String line = "";        while ((line = in.readLine()) != null) {            System.out.println(line);}        BufferedReader err = new BufferedReader(new InputStreamReader(p1.getErrorStream()));        String lineerr = "";        while ((lineerr = err.readLine()) != null) {            System.out.println(lineerr);        }        p1.getErrorStream().close();        p1.getInputStream().close();        p1.getOutputStream().close();        } catch (Exception e){System.out.println("Problem downloading file " + lfn+" from LFN"); e.printStackTrace();}if (p1.exitValue() != 0)           {throw new Exception("Lcg-cp returned error code " + p1.exitValue());}String[] parse=nb_particule_max.split("[Ee \t]",3);        float max = Float.parseFloat(parse[0]);         parse[1] = parse[1].replace('+','0');         if ( parse[1].matches("^[0-9]+") ) {            int exp = Integer.parseInt(parse[1]);            for (int i = 0; i&lt;exp; i++)                {max = max*10; }        }int n1=0;int ana=1;  Simu_file  chaine_untest =new Simu_file( lfn.substring(lfn.lastIndexOf('/')+1) );    int mode=chaine_untest.getCalculMode();    switch (mode) {        case 0:break;        case 1:            ana = 0;            n1=chaine_untest.getParticules();        break;        case 2:            n1= chaine_untest.getParticules();        break;    }int n2 = Integer.parseInt(nb_jobs_max);int n3 = (int) max;int n;if ( n1 == 0 )     { n = 0;}else {    if ( n1 &lt;=  n3  )       { n = Integer.parseInt(nbsplit_default_value);}    else {        n = n1/n3;        if ( n1%n3 != 0 )            { n++; }      }    n = Math.min(n, (n2 - ana) ) ; }int loop = 1 - ana;analytic = String.valueOf(ana);nb_split = String.valueOf(n);split_id = new ArrayList();chaine_vector = new ArrayList();nbsplit_vector = new ArrayList(); for (int i = loop; i&lt;=Math.max(n,loop);i++) {        split_id.add(""+i);        chaine_vector.add(simufile);        nbsplit_vector.add(nb_split);    }/*------------------End of Beanshell--------------*/      </beanshell>    </processor>    <processor name="get_min_element" >      <in name="array" type="string" depth="1" />      <out name="singleton" type="string" depth="0" />      <beanshell>int minvalue= Integer.parseInt(array.get(0));for (int i=1; i&lt; array.size(); i++) {     int value= Integer.parseInt(array.get(i));     int minvalue = Math.min(value,minvalue);}singleton = minvalue.toString();      </beanshell>    </processor>    <processor name="putOnWebServer" >      <in name="pendingFile" type="string" depth="0" />      <in name="dir" type="string" depth="0" />      <in name="lfn" type="string" depth="0" />      <out name="out" type="string" depth="0" />      <iterationstrategy>        <cross>          <port name="pendingFile" />          <port name="dir" />          <port name="lfn" />        </cross>      </iterationstrategy>      <beanshell>lfn = lfn.substring(lfn.indexOf("/grid"));//creates dir in case it doesn't exist yet        File d = new File(dir);        if(!d.exists()){            System.out.println("Creating dir "+dir);            if(!d.mkdir())                throw new Exception("Cannot create directory "+dir);        }        //lock file        Process p1 = null;        Runtime rt = Runtime.getRuntime();        String[] cmd1 = new String[2];        cmd1[0] = "lockfile";        cmd1[1] = pendingFile+".lock";        System.out.println("Waiting for lock on file "+pendingFile);        p1 = rt.exec(cmd1);        p1.waitFor();        p1.getErrorStream().close();        p1.getOutputStream().close();        p1.getInputStream().close();        System.out.println("Obtained lock on file "+pendingFile);        //write in file        InetAddress addr = InetAddress.getLocalHost();        String user = System.getenv("USER");        String pwd = System.getenv("PWD");        String filename=lfn.substring(lfn.lastIndexOf('/'));        FileWriter fw = new FileWriter(pendingFile,true);        fw.write(lfn+";"+user+"@"+addr.getCanonicalHostName()+":"+pwd+"/"+dir+"/"+filename+"\n");        fw.close();        //unlock file        System.out.println("Unlocking file "+pendingFile+".lock");        if((new File(pendingFile+".lock").delete()))            System.out.println("File "+pendingFile+".lock was successfully deleted");        else            throw new Exception("File "+pendingFile+".lock couldn't be deleted: the semaphore is inconsistent from now");        out = "https://"+addr.getCanonicalHostName()+"/workflows/"+(new File(pwd)).getName()+"/data/"+(new File(lfn)).getName();      </beanshell>    </processor>    <processor name="putOnWebServer_2" >      <in name="pendingFile" type="string" depth="0" />      <in name="dir" type="string" depth="0" />      <in name="lfn" type="string" depth="0" />      <out name="out" type="string" depth="0" />      <iterationstrategy>        <cross>          <port name="pendingFile" />          <port name="dir" />          <port name="lfn" />        </cross>      </iterationstrategy>      <beanshell>lfn = lfn.substring(lfn.indexOf("/grid"));//creates dir in case it doesn't exist yet        File d = new File(dir);        if(!d.exists()){            System.out.println("Creating dir "+dir);            if(!d.mkdir())                throw new Exception("Cannot create directory "+dir);        }        //lock file        Process p1 = null;        Runtime rt = Runtime.getRuntime();        String[] cmd1 = new String[2];        cmd1[0] = "lockfile";        cmd1[1] = pendingFile+".lock";        System.out.println("Waiting for lock on file "+pendingFile);        p1 = rt.exec(cmd1);        p1.waitFor();        p1.getErrorStream().close();        p1.getOutputStream().close();        p1.getInputStream().close();        System.out.println("Obtained lock on file "+pendingFile);        //write in file        InetAddress addr = InetAddress.getLocalHost();        String user = System.getenv("USER");        String pwd = System.getenv("PWD");        String filename=lfn.substring(lfn.lastIndexOf('/'));        FileWriter fw = new FileWriter(pendingFile,true);        fw.write(lfn+";"+user+"@"+addr.getCanonicalHostName()+":"+pwd+"/"+dir+"/"+filename+"\n");        fw.close();        //unlock file        System.out.println("Unlocking file "+pendingFile+".lock");        if((new File(pendingFile+".lock").delete()))            System.out.println("File "+pendingFile+".lock was successfully deleted");        else            throw new Exception("File "+pendingFile+".lock couldn't be deleted: the semaphore is inconsistent from now");        out = "https://"+addr.getCanonicalHostName()+"/workflows/"+(new File(pwd)).getName()+"/data/"+(new File(lfn)).getName();      </beanshell>    </processor>  </processors>  <links>      <link from="scan_file" to="projection_count:scanfile" />      <link from="nb_jobs_max" to="projection_count:nb_jobs_max" />      <link from="sindbad:result0" to="TempFiles" />      <link from="geo" to="sindbad:input3" />      <link from="phantom" to="sindbad:input4" />      <link from="pegs4dat" to="sindbad:input5" />      <link from="projection_count:projection_id" to="sindbad:input7" />      <link from="nb_particules_par_job_max" to="split_count:nb_particule_max" />      <link from="chain" to="split_count:simufile" />      <link from="default_split" to="split_count:nbsplit_default_value" />      <link from="projection_count:nbproj_vector" to="sindbad:input8" />      <link from="projection_count:scan_vector" to="sindbad:input1" />      <link from="split_count:split_id" to="sindbad:input9" />      <link from="split_count:nbsplit_vector" to="sindbad:input10" />      <link from="split_count:chaine_vector" to="sindbad:input2" />      <link from="simulation_name" to="appendDate:dir" />      <link from="appendDate:result" to="sindbad:input6" />      <link from="projection_count:nb_split_max" to="get_min_element:array" />      <link from="get_min_element:singleton" to="split_count:nb_jobs_max" />      <link from="split_count:nb_split" to="test_use_split:nb_split" />      <link from="sindbad:result0" to="test_use_split:sindbad_result" />      <link from="split_count:nb_split" to="merge:input1" />      <link from="merge:result0" to="MC_merges" />      <link from="merge:result1" to="ResultFile_2" />      <link from="pegs4dat" to="merge:input7" />      <link from="phantom" to="merge:input6" />      <link from="geo" to="merge:input5" />      <link from="chain" to="merge:input4" />      <link from="split_count:analytic" to="merge:input2" />      <link from="test_use_split:lfn_output_else" to="putOnWebServer:lfn" />      <link from="test_use_split:lfn_output_else" to="ResultFile" />      <link from="dataDir" to="putOnWebServer:dir" />      <link from="pendingFile" to="putOnWebServer:pendingFile" />      <link from="merge:result1" to="putOnWebServer_2:lfn" />      <link from="dataDir" to="putOnWebServer_2:dir" />      <link from="pendingFile" to="putOnWebServer_2:pendingFile" />      <link from="putOnWebServer_2:out" to="LocalFile_2" />      <link from="split_count:analytic" to="count_in_dir:nb_ana" />      <link from="split_count:nb_split" to="count_in_dir:nb_mc" />      <link from="test_use_split:lfn_output_then" to="count_in_dir:directory" />      <link from="test_start_merge:out_else" to="wait" />      <link from="test_start_merge:out_then" to="merge:input0" />      <link from="count_in_dir:elsebranch" to="test_start_merge:else_in" />      <link from="count_in_dir:thenbranch" to="test_start_merge:then_in" />      <link from="putOnWebServer:out" to="new output" />      <link from="sindbad_release" to="sindbad:input0" />      <link from="sindbad_release" to="merge:input3" />  </links></workflow>