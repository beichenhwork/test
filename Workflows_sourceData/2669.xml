<?xml version="1.0" encoding="UTF-8" standalone="yes"?><ns2:tesla_experiment createTime="1317827504843" singleton="false" state="1" version="0" id="0" xmlns:ns2="http://spinfo.uni-koeln.de/tesla">    <documentCollections>        <entry>            <key>sig_1</key>            <value numberOfDocuments="1" width="370" posY="36" posX="288" type="text" localId="sig_1">                <description>A selection of 1 documents, created by jhermes</description>                <name>PIII Codebook</name>                <producesRoles>ri-1829638520</producesRoles>                <producesRoles>ri-1735033557</producesRoles>                <producesRoles>ri1399965943</producesRoles>                <documentReferences reader="8aaeed8a-e0ad-4897-8528-52cac1fcf161" md5="f8801f56b7b453d14c7628e754eda4b0" dataSourceId="tesla"/>                <temporaryId>aab49a4c-ccde-4b76-9fa0-c4e3f7ca1682</temporaryId>                <xmlId>aab49a4c-ccde-4b76-9fa0-c4e3f7ca1682</xmlId>            </value>        </entry>    </documentCollections>    <reader_component readerLevel="80" localId="8aaeed8a-e0ad-4897-8528-52cac1fcf161" version="0.1" name="Tika Reader" width="0" posY="0" posX="0">        <className>de.uni_koeln.spinfo.tesla.component.reader.tika.DefaultTikaReader</className>        <produces_role localId="ri-1829638520" localName="URLs" roleDefinitionId="de.uni_koeln.spinfo.tesla.roles.tokenizer.UrlDetector">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.expressions.impl.hibernate.data.Url</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.expressions.impl.hibernate.access.UrlAccessAdapter</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.hibernate.DefaultHibernateOutputAdapter</outputAdapterImplementation>            <idInChain>-1829638520</idInChain>            <displayName>URL Detector</displayName>            <description>General information about this role: Detects URLs.</description>        </produces_role>        <produces_role localId="ri1399965943" localName="Paragraphs" roleDefinitionId="de.uni_koeln.spinfo.tesla.roles.tokenizer.ParagraphDetector">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.tokenizer.impl.hibernate.data.Paragraph</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.tokenizer.impl.tunguska.access.TParagraphAccessAdapter</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.tunguska.DefaultTunguskaOutputAdapter$ProtoStuff</outputAdapterImplementation>            <idInChain>1399965943</idInChain>            <displayName>Paragraph Detector</displayName>            <description>General information about this role: Detects paragraph boundaries.</description>        </produces_role>        <produces_role localId="ri-1735033557" localName="DC Meta Data" roleDefinitionId="de.uni_koeln.spinfo.tesla.rolesystem.presets.roles.DublinCoreMetadataGenerator">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.dc.impl.hibernate.DublinCoreMetaDataImpl</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.dc.impl.hibernate.DublinCoreMetaDataAccessAdapterImpl</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.hibernate.DefaultHibernateOutputAdapter</outputAdapterImplementation>            <idInChain>-1735033557</idInChain>            <displayName>Dublin Core Metadata Generator</displayName>            <description>General information about this role: Generates Dublin Core metadata annotations.</description>        </produces_role>        <consumes_role/>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Detect URLs">            <description>If enabled (default), the reader will detect URLs and generate corresponding annotations.</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Reuse Results">            <description>If false, this component will be executed whenever used in an experiment. If true, the annotations produced by this component earlier will be reused if the execution prerequesites did not change.</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <author login="anonymous">            <name>Stephan Schwiebert</name>            <email>sschwieb@spinfo.uni-koeln.de</email>            <organization>Department of Computational Linguistics, University of Cologne</organization>            <reference>http://www.spinfo.phil-fak.uni-koeln.de/sschwieb.html</reference>        </author>        <description>A general purpose reader which uses Apache Tika, such that it supports various formats, like RTF, PDF, ODF, HTML and MS Office. Note, however, that the structure of a document will not be extracted or annotated.</description>        <consumedSignals>            <item type="text" referencedObject="aab49a4c-ccde-4b76-9fa0-c4e3f7ca1682" name="fixme 789"/>        </consumedSignals>        <webReference>http://tika.apache.org/</webReference>        <type>java.lang.String</type>    </reader_component>    <component localId="dc0efb56-1fc1-4d6d-83cd-d51e9594e5b9" version="1.0" name="SPre" width="190" posY="152" posX="256">        <className>de.uni_koeln.spinfo.tesla.component.spre.SPre2Component</className>        <produces_role localId="ri-323954086" localName="Tokens" roleDefinitionId="de.uni_koeln.spinfo.tesla.roles.tokenizer.Tokenizer">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.core.impl.hibernate.data.Token</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.tokenizer.impl.tunguska.access.TTokenizerAccessAdapter</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.tunguska.DefaultTunguskaOutputAdapter$ProtoStuff</outputAdapterImplementation>            <idInChain>-323954086</idInChain>            <displayName>Tokenizer</displayName>            <description>General information about this role: Detects linguistic tokens.</description>        </produces_role>        <produces_role localId="ri-2137110467" localName="Sentences" roleDefinitionId="de.uni_koeln.spinfo.tesla.roles.tokenizer.SentenceDetector">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.tokenizer.impl.hibernate.data.Sentence</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.tokenizer.impl.tunguska.access.TSentenceTokenAccessAdapter</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.tunguska.DefaultTunguskaOutputAdapter$ProtoStuff</outputAdapterImplementation>            <idInChain>-2137110467</idInChain>            <displayName>Sentence Detector</displayName>            <description>General information about this role: Detects sentence boundaries.</description>        </produces_role>        <consumes_role/>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.FallbackConfigurationEditor" category="Parser 1 Config">            <description>Configurations for the SPre Character parser</description>            <value>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;spre:characterParser    xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"    xmlns:spre="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreCharacterParser"    xs:schemaLocation="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreCharacterParser SPreCharacterParser.xsd"&gt;    &lt;spre:layer&gt;CharacterLayer&lt;/spre:layer&gt;    &lt;spre:tokens&gt;        &lt;!-- ++++++++++++ --&gt;        &lt;!-- Letter &amp; digit items will be generated --&gt;        &lt;!-- ++++++++++++ --&gt;        &lt;spre:token name="generateUnicodeTokens"&gt;config&lt;/spre:token&gt;        &lt;!-- +++++++++++++++++ --&gt;        &lt;!-- Punctuation items --&gt;        &lt;!-- +++++++++++++++++ --&gt;        &lt;spre:token name="Dot"&gt;.&lt;/spre:token&gt;        &lt;spre:token name="QuestionMark"&gt;?&lt;/spre:token&gt;        &lt;spre:token name="ExclamationMark"&gt;!&lt;/spre:token&gt;        &lt;spre:token name="Comma"&gt;,&lt;/spre:token&gt;        &lt;spre:token name="Colon"&gt;:&lt;/spre:token&gt;        &lt;spre:token name="SemiColon"&gt;;&lt;/spre:token&gt;        &lt;spre:token name="Hyphen"&gt;-&lt;/spre:token&gt;        &lt;spre:token name="ParenthesisOpen"&gt;(&lt;/spre:token&gt;        &lt;spre:token name="ParenthesisClose"&gt;)&lt;/spre:token&gt;        &lt;spre:token name="BracketOpen"&gt;[&lt;/spre:token&gt;        &lt;spre:token name="BracketClose"&gt;]&lt;/spre:token&gt;        &lt;spre:token name="BraceOpen"&gt;{&lt;/spre:token&gt;        &lt;spre:token name="BraceClose"&gt;}&lt;/spre:token&gt;        &lt;spre:token name="LowerThan"&gt;&amp;lt;&lt;/spre:token&gt;        &lt;spre:token name="GreaterThan"&gt;&amp;gt;&lt;/spre:token&gt;        &lt;spre:token name="Apostroph"&gt;&amp;apos;&lt;/spre:token&gt;        &lt;spre:token name="Quotation"&gt;&amp;quot;&lt;/spre:token&gt;        &lt;spre:token name="Slash"&gt;/&lt;/spre:token&gt;        &lt;spre:token name="Backslash"&gt;\&lt;/spre:token&gt;        &lt;!-- +++++++++++++++ --&gt;        &lt;!-- Line feed items --&gt;        &lt;!-- +++++++++++++++ --&gt;        &lt;spre:token name="LineFeed"&gt;&amp;#x000a;&lt;/spre:token&gt;        &lt;spre:token name="CRLineFeed"&gt;&amp;#x000d;&amp;#x000a;&lt;/spre:token&gt;        &lt;!-- +++++++++++++++++ --&gt;        &lt;!-- White space items --&gt;        &lt;!-- +++++++++++++++++ --&gt;        &lt;!-- Character-Tab --&gt;        &lt;spre:token name="Tab"&gt;&amp;#x0009;&lt;/spre:token&gt;        &lt;!-- Blank --&gt;        &lt;spre:token name="Space"&gt;&amp;#x0020;&lt;/spre:token&gt;        &lt;!-- +++++++++++++ --&gt;        &lt;!-- Further items --&gt;        &lt;!-- +++++++++++++ --&gt;        &lt;spre:token name="Paragraph"&gt;§&lt;/spre:token&gt;        &lt;spre:token name="Percent"&gt;%&lt;/spre:token&gt;        &lt;spre:token name="Ampersand"&gt;&amp;#x0026;&lt;/spre:token&gt;        &lt;spre:token name="Equals"&gt;=&lt;/spre:token&gt;        &lt;spre:token name="Asterisk"&gt;*&lt;/spre:token&gt;        &lt;spre:token name="Plus"&gt;+&lt;/spre:token&gt;        &lt;spre:token name="Sharp"&gt;#&lt;/spre:token&gt;        &lt;spre:token name="Underscore"&gt;_&lt;/spre:token&gt;        &lt;spre:token name="ParagraphSeparator"&gt;&amp;#x2029;&lt;/spre:token&gt;    &lt;/spre:tokens&gt;    &lt;spre:tokenClasses&gt;        &lt;!-- Letter and Digit classes will be auto generated! --&gt;        &lt;spre:tokenClass name="Stop"&gt;            &lt;spre:item&gt;SemiStop&lt;/spre:item&gt;            &lt;spre:item&gt;FullStop&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="SemiStop"&gt;            &lt;spre:item&gt;Comma&lt;/spre:item&gt;            &lt;spre:item&gt;Colon&lt;/spre:item&gt;            &lt;spre:item&gt;SemiColon&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="FullStop"&gt;            &lt;spre:item&gt;Dot&lt;/spre:item&gt;            &lt;spre:item&gt;QuestionMark&lt;/spre:item&gt;            &lt;spre:item&gt;ExclamationMark&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="Punctuation"&gt;            &lt;spre:item&gt;Stop&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="Parenthetical"&gt;            &lt;spre:item&gt;ParentheticalOpen&lt;/spre:item&gt;            &lt;spre:item&gt;ParentheticalClose&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="ParentheticalOpen"&gt;            &lt;spre:item&gt;ParenthesisOpen&lt;/spre:item&gt;            &lt;spre:item&gt;BracketOpen&lt;/spre:item&gt;            &lt;spre:item&gt;BraceOpen&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="ParentheticalClose"&gt;            &lt;spre:item&gt;ParenthesisClose&lt;/spre:item&gt;            &lt;spre:item&gt;BracketClose&lt;/spre:item&gt;            &lt;spre:item&gt;BraceClose&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="WhiteSpace"&gt;            &lt;spre:item&gt;Tab&lt;/spre:item&gt;            &lt;spre:item&gt;Space&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;!-- This class comprises everything that clearly divides words above including WhiteSpace --&gt;        &lt;spre:tokenClass name="Divider"&gt;            &lt;spre:item&gt;NewLine&lt;/spre:item&gt;            &lt;spre:item&gt;WhiteSpace&lt;/spre:item&gt;            &lt;spre:item&gt;Plus&lt;/spre:item&gt;            &lt;spre:item&gt;Paragraph&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="NewLine"&gt;            &lt;spre:item&gt;LineFeed&lt;/spre:item&gt;            &lt;spre:item&gt;CRLineFeed&lt;/spre:item&gt;            &lt;spre:item&gt;ParagraphSeparator&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="Other"&gt;            &lt;spre:item&gt;Percent&lt;/spre:item&gt;            &lt;spre:item&gt;Ampersand&lt;/spre:item&gt;            &lt;spre:item&gt;Equals&lt;/spre:item&gt;            &lt;spre:item&gt;Asterisk&lt;/spre:item&gt;            &lt;spre:item&gt;Sharp&lt;/spre:item&gt;            &lt;spre:item&gt;Underscore&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;    &lt;/spre:tokenClasses&gt;&lt;/spre:characterParser&gt;</value>            <comment>Character parser for all unicoded texts</comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="0" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.FallbackConfigurationEditor" category="Parser 2 Config">            <description>Configurations for the SPre parser based on the character parser</description>            <value>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;spre:defaultParser    xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"    xmlns:spre="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreDefaultParser"    xs:schemaLocation="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreDefaultParser SPreDefaultParser.xsd"&gt;    &lt;!-- ************* --&gt;    &lt;!-- 1. The tokens --&gt;    &lt;!-- ************* --&gt;    &lt;spre:layer&gt;WordLayer&lt;/spre:layer&gt;    &lt;spre:tokens&gt;        &lt;!-- The tokenClass Unprocessable will always be generated by the        characterParser. It's a bit problematic that the name is only fixed        on the level of the source code. --&gt;        &lt;spre:token name="UnprocessableTokenSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Unprocessable&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;Unprocessable&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="UnprocessableToken"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Unprocessable&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;!-- ******************** --&gt;        &lt;!-- 1.1 The "Word" token --&gt;        &lt;!-- ******************** --&gt;            &lt;spre:token name="Word"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Letter&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;Alphanumeric&lt;/spre:contains&gt;                &lt;spre:contains&gt;Dot&lt;/spre:contains&gt;                &lt;spre:contains&gt;Hyphen&lt;/spre:contains&gt;                &lt;spre:contains&gt;Slash&lt;/spre:contains&gt;                &lt;spre:contains&gt;Backslash&lt;/spre:contains&gt;                &lt;spre:ambiguity&gt;                    &lt;spre:element&gt;Dot&lt;/spre:element&gt;                    &lt;!-- Merge the ambigue element with the previous element's belonging                    WordLevel-element if the condition isAbbreviation is met. --&gt;                    &lt;spre:merge type="left"&gt;                          &lt;spre:sequence&gt;                            &lt;spre:element&gt;Letter&lt;/spre:element&gt;                            &lt;spre:element&gt;Dot&lt;/spre:element&gt;                            &lt;spre:element&gt;Divider&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                       &lt;!--The idea is that conditions call methods, defined in &lt;spre:condition ...&gt;,                        to check for special properties of the item in question. The parameters                        of the respective method is String, in this case the Token "Word" that                        results by applying this Merge operation.--&gt;                      &lt;spre:conditions&gt;                            &lt;spre:condition&gt;Abbreviations&lt;/spre:condition&gt;                        &lt;/spre:conditions&gt;                     &lt;/spre:merge&gt;                  &lt;spre:merge type="left"&gt;                        &lt;spre:sequence&gt;                            &lt;spre:element&gt;Letter&lt;/spre:element&gt;                            &lt;spre:element&gt;Dot&lt;/spre:element&gt;                            &lt;spre:element&gt;Divider&lt;/spre:element&gt;                            &lt;spre:element&gt;LowerCaseLetter&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                    &lt;/spre:merge&gt;                    &lt;!-- Merge all three elements to one of the type of the first element's                    WordLevel-element type. --&gt;                    &lt;spre:merge type="leftright"&gt;                        &lt;spre:sequence&gt;                            &lt;spre:element&gt;Alphanumeric&lt;/spre:element&gt;                            &lt;spre:element&gt;Dot&lt;/spre:element&gt;                            &lt;spre:element&gt;Alphanumeric&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                    &lt;/spre:merge&gt;                &lt;/spre:ambiguity&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;!-- ************************* --&gt;        &lt;!-- 1.2 The "Numerical" token --&gt;        &lt;!-- ************************* --&gt;        &lt;spre:token name="Numerical"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Digit&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;Digit&lt;/spre:contains&gt;                &lt;spre:contains&gt;Digit&lt;/spre:contains&gt;                &lt;spre:contains&gt;Dot&lt;/spre:contains&gt;                &lt;spre:contains&gt;Comma&lt;/spre:contains&gt;                &lt;spre:contains&gt;Slash&lt;/spre:contains&gt;                &lt;!-- First amgigue Element: "Dot" --&gt;                &lt;spre:ambiguity&gt;                    &lt;spre:element&gt;Dot&lt;/spre:element&gt;                    &lt;!--                    E.g. &lt;spre:merge Type="leftright"&gt;                    ... i n  4 3 . 5 %  a l l e r F ä l l e ...                    Here, "43.5" will be recognized as one token                    and merging "leftright" means that both parts                    left and right of the ambigue element "." will                    be joined.                    --&gt;                    &lt;spre:merge type="leftright"&gt;                        &lt;spre:sequence&gt;                            &lt;spre:element&gt;Digit&lt;/spre:element&gt;                            &lt;spre:element&gt;Dot&lt;/spre:element&gt;                            &lt;spre:element&gt;Digit&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                    &lt;/spre:merge&gt;                    &lt;!--                    E.g. &lt;spre:merge Type="left"&gt;                    ... b e i  d e r  2 0 .  ö f f e n t l i c h  a u s g e t r a g e n e n ...                    Here, "20." will be recognized as one token and merging                    'left' means that the dot will be interpreted as part of the                    numerical expression.                    --&gt;                    &lt;spre:merge type="left"&gt;                        &lt;spre:sequence&gt;                            &lt;spre:element&gt;Digit&lt;/spre:element&gt;                            &lt;spre:element&gt;Dot&lt;/spre:element&gt;                            &lt;spre:element&gt;WhiteSpace&lt;/spre:element&gt;                            &lt;spre:element&gt;LowerCaseLetter&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                    &lt;/spre:merge&gt;                &lt;/spre:ambiguity&gt;                &lt;!-- Second ambigue element: "Comma" --&gt;                &lt;spre:ambiguity&gt;                    &lt;!--                    E.g. &lt;spre:merge Type="leftright"&gt;                    ... i n  4 3 , 5 %  a l l e r F ä l l e ...                    Here, "43,5" will be recognized as one token                    and merging "leftright" means that both parts                    left and right of the ambigue element "." will                    be joined.                    --&gt;                    &lt;spre:element&gt;Comma&lt;/spre:element&gt;                    &lt;spre:merge type="leftright"&gt;                        &lt;spre:sequence&gt;                            &lt;spre:element&gt;Digit&lt;/spre:element&gt;                            &lt;spre:element&gt;Comma&lt;/spre:element&gt;                            &lt;spre:element&gt;Digit&lt;/spre:element&gt;                        &lt;/spre:sequence&gt;                    &lt;/spre:merge&gt;                &lt;/spre:ambiguity&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;!-- **************** --&gt;        &lt;!-- 1.3 Other tokens --&gt;        &lt;!-- **************** --&gt;        &lt;spre:token name="FullStopSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Dot&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;Dot&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="ExclamationMarkSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;ExclamationMark&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;ExclamationMark&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="QuestionMarkSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;QuestionMark&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;QuestionMark&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="MixedSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;ExclamationMark&lt;/spre:startsWith&gt;                &lt;spre:startsWith&gt;QuestionMark&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;ExclamationMark&lt;/spre:contains&gt;                &lt;spre:contains&gt;QuestionMark&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;         &lt;spre:token name="Apostroph"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Apostroph&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="Slash"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Slash&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="FullStop"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Dot&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="ExclamationMark"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;ExclamationMark&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="QuestionMark"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;QuestionMark&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="Comma"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Comma&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="Colon"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Colon&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="SemiColon"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;SemiColon&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="SingleQuote"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Apostroph&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="DoubleQuote"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Quotation&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="ParentheticalOpen"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;ParentheticalOpen&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="ParentheticalClosed"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;ParentheticalClose&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="NewLine"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;NewLine&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="ParagraphSeparator"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;ParagraphSeparator&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;    &lt;/spre:tokens&gt;    &lt;!-- ******************* --&gt;    &lt;!-- 2. The tokenClasses --&gt;    &lt;!-- ******************* --&gt;    &lt;spre:tokenClasses&gt;        &lt;spre:tokenClass name="Unprocessable"&gt;            &lt;spre:item&gt;UnprocessableToken&lt;/spre:item&gt;            &lt;spre:item&gt;UnprocessableTokenSequence&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;        &lt;spre:tokenClass name="FullStops"&gt;            &lt;spre:item&gt;FullStop&lt;/spre:item&gt;            &lt;spre:item&gt;ExclamationMark&lt;/spre:item&gt;            &lt;spre:item&gt;QuestionMark&lt;/spre:item&gt;        &lt;/spre:tokenClass&gt;    &lt;/spre:tokenClasses&gt;&lt;/spre:defaultParser&gt;</value>            <comment>Word parser for german texts</comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="0" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.FallbackConfigurationEditor" category="Parser 3 Config">            <description>Configurations for the SPre parser based on the secondary parser</description>            <value>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;spre:defaultParser    xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"    xmlns:spre="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreDefaultParser"    xs:schemaLocation="http://spinfo.uni_koeln.de/spre/xmlSchema/SPreDefaultParser SPreDefaultParser.xsd"&gt;    &lt;spre:layer&gt;SentenceLayer&lt;/spre:layer&gt;    &lt;!-- ************* --&gt;    &lt;!-- 1. The tokens --&gt;    &lt;!-- ************* --&gt;    &lt;spre:tokens&gt;        &lt;!-- The tokenClass Unprocessable will always be generated by the        characterParser. It's a bit problematic that the name is only fixed        on the level of the source code. --&gt;        &lt;spre:token name="UnprocessableTokenSequence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Unprocessable&lt;/spre:startsWith&gt;                &lt;spre:contains&gt;Unprocessable&lt;/spre:contains&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;spre:token name="UnprocessableToken"&gt;            &lt;spre:pattern&gt;                &lt;spre:containsOnly&gt;Unprocessable&lt;/spre:containsOnly&gt;            &lt;/spre:pattern&gt;        &lt;/spre:token&gt;        &lt;!-- ******************** --&gt;        &lt;!-- 1.1 The "Sentence" token --&gt;        &lt;!-- ******************** --&gt;        &lt;spre:token name="Sentence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Word&lt;/spre:startsWith&gt;                &lt;spre:endsWith&gt;FullStops&lt;/spre:endsWith&gt;            &lt;/spre:pattern&gt;                   &lt;/spre:token&gt;&lt;!-- 	&lt;spre:token name="NoSentence"&gt;            &lt;spre:pattern&gt;                &lt;spre:startsWith&gt;Word&lt;/spre:startsWith&gt;                &lt;spre:endsWith&gt;NewLine&lt;/spre:endsWith&gt;            &lt;/spre:pattern&gt;                   &lt;/spre:token&gt; --&gt;            &lt;/spre:tokens&gt;     &lt;spre:tokenClasses&gt;        &lt;spre:tokenClass name="Sentence"&gt;            &lt;spre:item&gt;Sentence&lt;/spre:item&gt;                    &lt;/spre:tokenClass&gt;  &lt;!--		&lt;spre:tokenClass name="NoSentence"&gt;            &lt;spre:item&gt;NoSentence&lt;/spre:item&gt;                    &lt;/spre:tokenClass&gt;        --&gt;       &lt;/spre:tokenClasses&gt;  &lt;/spre:defaultParser&gt;</value>            <comment>Sentence parser for german texts</comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.NamedListEditor" category="Abbreviations">            <description>List of abbreviations</description>            <value>AbbreviationsA.A.A.a.a.a.a.O.Abb.Abbr.Abg.Abk.Abs.Abt.A.C.A.D.a.d.a.D.agr.allg.Alt.a.m.amerik.Anm.a.o.A.T.B.B.c.B.C.Bd.Bev.Bj.Bsp.Btl.bzw.C.ca.chin.Co.Ct.D.D.C.Dez.d.h.Di.Dipl.Do.Dr.dt.E.e.e.G.engl.etc.e.V.ev.F.f.Fr.franz.G.Gef.gegr.gem.ggf.GMBl.Grp.H.habil.Hbf.hist.höchst.Hptm.I.i.A.id.i.d.F.I.K.I.L.Inc.incl.inkl.i.S.v.ital.i.V.i.V.m.J.jap.Jh.jmd.Jt.K.kath.K.O.Kp.L.lat.Ld.Lj.M.m.m.b.L.med.Mi.Mill.Min.mind.Mio.Mo.Mr.Mrd.Mrs.Msp.m.W.v.N.Nr.N.T.N.Y.o.g.O.o.O.P.p.a.Pfd.pl.p.m.P.M.Prof.prot.Q.Q.b.A.q.e.d.Qual.Quant.R.reg.rer.S.Sa.san.sgl.So.sog.span.Std.Str.-str.svw.T.Tel.U.u.a.ugs.urspr.usw.u.ä.u.U.V.v.Chr.Vfg.Vgl.v.H.vs.W.Wdh.Wv.X.Y.Z.z.A.z.B.Zbl.z.d.A.z.Hd.Zi.z.T.Ztr.z.V.zw.z.Z.z.Zt.zzgl.ä.Ä.ö.Ö.ü.Ü.</value>            <comment>List of german abbreviations</comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Reuse Results">            <description>If false, this component will be executed whenever used in an experiment. If true, the annotations produced by this component earlier will be reused if the execution prerequesites did not change.</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <author login="anonymous">            <name>Jürgen Hermes</name>            <email>jhermes@spinfo.uni-koeln.de</email>            <organization>Sprachliche Informationsverarbeitung</organization>            <reference>http://www.phil-fak.uni-koeln.de/spinfo-juergenhermes.html</reference>        </author>        <author login="anonymous">            <name>Christoph Benden</name>            <email>cbenden@spinfo.uni-koeln.de</email>            <organization>Sprachliche Informationsverarbeitung</organization>            <reference>No external URL defined</reference>        </author>        <description>A configurable layered tokenizer.</description>        <consumedSignals>            <item type="text" referencedObject="aab49a4c-ccde-4b76-9fa0-c4e3f7ca1682" name="texts"/>        </consumedSignals>        <webReference>No external URL defined</webReference>    </component>    <component localId="d6bfa7b4-b0d7-47d2-9b8c-bb5a6d10ebc9" version="1.0" name="Graphemizer" width="150" posY="310" posX="275">        <className>de.uni_koeln.spinfo.formanalysis.teslacomponents.GraphemizerComponent</className>        <produces_role localId="ri1363302121" localName="Grapheme Distribution" roleDefinitionId="de.uni_koeln.spinfo.tesla.structuralism.GraphemeVectorGenerator">            <dataObjectImplementation>de.uni_koeln.spinfo.formanalysis.teslacomponents.dataobject.GraphemeVector</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.vectorengine.access.impl.tunguska.DoubleVectorAccessAdapter</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.tunguska.DefaultTunguskaOutputAdapter</outputAdapterImplementation>            <idInChain>1363302121</idInChain>            <displayName>GraphemeVectorGenerator</displayName>            <description>General information about this role: Detects graphems using minimal pair analysis. Provides access on graphemes, minimal pairs and minimal pair contexts with additional distributive data.</description>        </produces_role>        <consumes_role>            <item name="Words">                <includedObject xsi:type="roleDefinition" localId="-323954086" local_id="ri-323954086" maxOccurrences="1" minOccurrences="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">                    <displayName>Tokenizer</displayName>                    <description>Detects linguistic tokens.</description>                    <roleDefinitionId>de.uni_koeln.spinfo.tesla.roles.tokenizer.Tokenizer</roleDefinitionId>                    <implementingComponent>dc0efb56-1fc1-4d6d-83cd-d51e9594e5b9</implementingComponent>                    <idInChain>-323954086</idInChain>                    <accessAdapterInterface>de.uni_koeln.spinfo.tesla.roles.tokenizer.access.ITokenAccessAdapter</accessAdapterInterface>                    <dataObjectInterface>de.uni_koeln.spinfo.tesla.roles.tokenizer.data.IToken</dataObjectInterface>                </includedObject>            </item>        </consumes_role>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.IntegerEditor" category="Min word length">            <description>Determines how many occurences a type should have at least to be analyzed</description>            <value>2</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="To lower case">            <description>If true, every letter will be lower cased before analysis</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Add partners to vector">            <description>If true, the minimal pair partners of the graphemes will be added to the result vector</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Add contexts to vector">            <description>If true, the minimal pair contexts of the graphemes will be added to the result vector</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Add forward distribution to vector">            <description>If true, the left-right-distribution of the graphemes will be added to the result vector</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Add backward distribution to vector">            <description>If true, the right-left-distribution of the graphemes will be added to the result vector</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.IntegerEditor" category="Count weight">            <description>Determines, how often the count will be added to the result vector (0 if it should not be added)</description>            <value>1</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Label based statistics">            <description>if true, the word labels will be analysed instead of the signal content.</description>            <value>false</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Reuse Results">            <description>If false, this component will be executed whenever used in an experiment. If true, the annotations produced by this component earlier will be reused if the execution prerequesites did not change.</description>            <value>false</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <author login="anonymous">            <name>Jürgen Hermes</name>            <email>jhermes@spinfo.uni-koeln.de</email>            <organization>Sprachliche Informationsverarbeitung</organization>            <reference>none</reference>        </author>        <description>Detects Graphemes using minimal pair analysis.</description>        <consumedSignals/>        <webReference>none</webReference>    </component>    <component localId="3e285f8f-f2bf-4148-a96b-05b97d25ff7a" version="1.0" name="K-Means++ Clusterer" width="150" posY="288" posX="553">        <className>de.uni_koeln.spinfo.tesla.component.kmeans.KMeansClustererComponent</className>        <produces_role localId="ri264526094" localName="Clusters" roleDefinitionId="de.uni_koeln.spinfo.tesla.roles.cluster.WeightedClusterer">            <dataObjectImplementation>de.uni_koeln.spinfo.tesla.roles.cluster.impl.db4o.data.WeightedLabeledCluster</dataObjectImplementation>            <inputAdapterImplementation>de.uni_koeln.spinfo.tesla.roles.cluster.impl.db4o.access.WeightedClusterAccessAdapter</inputAdapterImplementation>            <outputAdapterImplementation>de.uni_koeln.spinfo.tesla.annotation.adapter.db4o.DefaultDB4OOutputAdapter</outputAdapterImplementation>            <idInChain>264526094</idInChain>            <displayName>Weighted Clusterer</displayName>            <description>General information about this role: Generates a weighted cluster.If produced by 'K-Means++ Clusterer': k different clusters. Each vector from 'Vectors' is assigned to exactly one cluster.</description>        </produces_role>        <consumes_role>            <item name="Vectors">                <includedObject xsi:type="roleDefinition" localId="1363302121" local_id="ri1363302121" maxOccurrences="1" minOccurrences="1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">                    <displayName>Vector Generator</displayName>                    <description>General information about this role: Generates a vector representation of the processed data.If consumed by 'K-Means++ Clusterer': The vectors which will be clustered.</description>                    <roleDefinitionId>de.uni_koeln.spinfo.tesla.roles.vectors.VectorGenerator</roleDefinitionId>                    <implementingComponent>d6bfa7b4-b0d7-47d2-9b8c-bb5a6d10ebc9</implementingComponent>                    <idInChain>1363302121</idInChain>                    <accessAdapterInterface>de.uni_koeln.spinfo.tesla.roles.vectorengine.access.IVectorAccessAdapter</accessAdapterInterface>                    <dataObjectInterface>de.uni_koeln.spinfo.tesla.roles.vectorengine.data.IVector</dataObjectInterface>                </includedObject>            </item>        </consumes_role>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.IntegerEditor" category="Random Seed">            <description>Random Seed for the cluster algorithm. Depending on this value, initial cluster centers will be chosen (see http://en.wikipedia.org/wiki/K-means++ for details). If set to -1, a new seed will be used each time the component is executed. Note that you might want to set 'resuable results' to 'false' in this case.</description>            <value>0</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.IntegerEditor" category="Number of clusters">            <description>The number of clusters. Choose this value with care, as the optimal number of clusters highly depends on the properties of the clustered data. If set to -1 (which is the default value), the number of clusters will be guessed with a simple rule of thumb: k = sqrt(n/2), where n is the number of vectors to cluster.See http://en.wikipedia.org/wiki/K-means_clustering and http://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set for details.</description>            <value>3</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.IntegerEditor" category="Maximum number of iterations">            <description>The maximum number of iterations. During each iteration, cluster centers may be modified and each vector may be assigned to a different cluster. If no cluster center was modified during an iteration, the algorithm terminates. Increasing this number will usually create better results, but also slow down the performance of the calcuation.</description>            <value>50</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.ServerSubclassChoice" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.ServerChoiceEditor" category="Distance Function">            <description>The distance function to compare two vectors.</description>            <value>de.uni_koeln.spinfo.tesla.roles.vectorengine.data.distance.NativeDistanceCalculator</value>            <comment></comment>            <editorConfigurations>de.uni_koeln.spinfo.tesla.roles.vectorengine.data.distance.IDistanceCalculator</editorConfigurations>            <editorConfigurations>single</editorConfigurations>            <editorConfigurations>class</editorConfigurations>            <evaulateRestrictiononServer>true</evaulateRestrictiononServer>        </configuration>        <configuration restriction="de.uni_koeln.spinfo.tesla.runtime.component.annotations.NoRestriction" maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Report Cluster Members">            <description>Indicates, if members of clusters should be displayed in the report.</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <configuration maximum="1" minimum="1" id="0" editorClassName="de.uni_koeln.spinfo.tesla.client.ui.editors.form.configurations.itemeditors.BooleanEditor" category="Reuse Results">            <description>If false, this component will be executed whenever used in an experiment. If true, the annotations produced by this component earlier will be reused if the execution prerequesites did not change.</description>            <value>true</value>            <comment></comment>            <evaulateRestrictiononServer>false</evaulateRestrictiononServer>        </configuration>        <author login="anonymous">            <name>Stephan Schwiebert</name>            <email>sschwieb@spinfo.uni-koeln.de</email>            <organization>Linguistic Data Processing, University of Cologne</organization>            <reference>http://www.spinfo.phil-fak.uni-koeln.de/sschwieb.html</reference>        </author>        <description>A simple KMeans++ Clusterer, which assigns vectors to K different clusters. The implementation of this component uses the KMeansPlusPlusClusterer of the apache.commons.math project.</description>        <consumedSignals/>        <webReference>http://en.wikipedia.org/wiki/K-means%2B%2B</webReference>    </component>    <displayName>Grapheme Analysis PIII</displayName>    <description>Analysis of graphemes form the ciphers of the PIII codebook</description>    <creator login="jhermes">        <name>jhermes</name>        <email>hermesj@uni-koeln.de</email>        <organization>none</organization>        <reference></reference>    </creator></ns2:tesla_experiment>